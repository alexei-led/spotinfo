
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>spotinfo: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">spotinfo/cmd/spotinfo/main.go (71.3%)</option>
				
				<option value="file1">spotinfo/internal/spot/client.go (86.1%)</option>
				
				<option value="file2">spotinfo/internal/spot/data.go (82.3%)</option>
				
				<option value="file3">spotinfo/internal/spot/types.go (88.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main provides the CLI application for spotinfo.
package main

import (
        "context"
        _ "embed"
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "os"
        "os/signal"
        "runtime"
        "strings"
        "syscall"

        "spotinfo/internal/spot" //nolint:gci // local import group

        "github.com/jedib0t/go-pretty/v6/table"
        "github.com/jedib0t/go-pretty/v6/text"
        "github.com/urfave/cli/v2" //nolint:gci
)

var (
        // main context
        mainCtx context.Context
        // logger instance
        log *slog.Logger
        // Version contains the current version.
        Version = "dev"
        // BuildDate contains a string with the build date.
        BuildDate = "unknown"
        // GitCommit git commit SHA
        GitCommit = "dirty"
        // GitBranch git branch
        GitBranch = "master"
)

const (
        regionColumn       = "Region"
        instanceTypeColumn = "Instance Info"
        vCPUColumn         = "vCPU"
        memoryColumn       = "Memory GiB"
        savingsColumn      = "Savings over On-Demand"
        interruptionColumn = "Frequency of interruption"
        priceColumn        = "USD/Hour"
)

//nolint:cyclop
func mainCmd(ctx *cli.Context) error <span class="cov1" title="1">{
        return execMainCmd(ctx, mainCtx, spot.New(), os.Stdout)
}</span>

// SpotClient interface defined close to consumer for testing (following codebase patterns)
type SpotClient interface {
        GetSpotSavings(ctx context.Context, regions []string, pattern, instanceOS string,
                cpu, memory int, maxPrice float64, sortBy spot.SortBy, sortDesc bool) ([]spot.Advice, error)
}

// execMainCmd is the testable version of mainCmd that accepts dependencies.
//
//nolint:cyclop
func execMainCmd(ctx *cli.Context, execCtx context.Context, client SpotClient, output io.Writer) error <span class="cov10" title="18">{
        if v := execCtx.Value("key"); v != nil </span><span class="cov1" title="1">{
                log.Debug("context value received", slog.Any("value", v))
        }</span>

        <span class="cov10" title="18">regions := ctx.StringSlice("region")
        instanceOS := ctx.String("os")
        instance := ctx.String("type")
        cpu := ctx.Int("cpu")
        memory := ctx.Int("memory")
        maxPrice := ctx.Float64("price")
        sortBy := ctx.String("sort")
        order := ctx.String("order")
        sortDesc := strings.EqualFold(order, "desc")

        var sortType spot.SortBy

        switch sortBy </span>{
        case "type":<span class="cov1" title="1">
                sortType = spot.SortByInstance</span>
        case "interruption":<span class="cov9" title="14">
                sortType = spot.SortByRange</span>
        case "savings":<span class="cov3" title="2">
                sortType = spot.SortBySavings</span>
        case "price":<span class="cov0" title="0">
                sortType = spot.SortByPrice</span>
        case "region":<span class="cov0" title="0">
                sortType = spot.SortByRegion</span>
        default:<span class="cov1" title="1">
                sortType = spot.SortByRange</span>
        }

        // get spot savings
        <span class="cov10" title="18">advices, err := client.GetSpotSavings(execCtx, regions, instance, instanceOS, cpu, memory, maxPrice, sortType, sortDesc)
        if err != nil </span><span class="cov4" title="3">{
                return fmt.Errorf("failed to get spot savings: %w", err)
        }</span>

        // decide if region should be printed
        <span class="cov9" title="15">printRegion := len(regions) &gt; 1 || (len(regions) == 1 &amp;&amp; regions[0] == "all")

        switch ctx.String("output") </span>{
        case "number":<span class="cov1" title="1">
                printAdvicesNumber(advices, printRegion, output)</span>
        case "text":<span class="cov1" title="1">
                printAdvicesText(advices, printRegion, output)</span>
        case "json":<span class="cov8" title="10">
                printAdvicesJSON(advices, output)</span>
        case "table":<span class="cov1" title="1">
                printAdvicesTable(advices, false, printRegion, output)</span>
        case "csv":<span class="cov1" title="1">
                printAdvicesTable(advices, true, printRegion, output)</span>
        default:<span class="cov1" title="1">
                printAdvicesNumber(advices, printRegion, output)</span>
        }

        <span class="cov9" title="15">return nil</span>
}

func printAdvicesText(advices []spot.Advice, region bool, output io.Writer) <span class="cov4" title="3">{
        for _, advice := range advices </span><span class="cov3" title="2">{
                if region </span><span class="cov1" title="1">{
                        fmt.Fprintf(output, "region=%s, type=%s, vCPU=%d, memory=%vGiB, saving=%d%%, interruption='%s', price=%.2f\n",
                                advice.Region, advice.Instance, advice.Info.Cores, advice.Info.RAM, advice.Savings, advice.Range.Label, advice.Price)
                }</span> else<span class="cov1" title="1"> {
                        fmt.Fprintf(output, "type=%s, vCPU=%d, memory=%vGiB, saving=%d%%, interruption='%s', price=%.2f\n",
                                advice.Instance, advice.Info.Cores, advice.Info.RAM, advice.Savings, advice.Range.Label, advice.Price)
                }</span>
        }
}

func printAdvicesNumber(advices []spot.Advice, region bool, output io.Writer) <span class="cov6" title="5">{
        if len(advices) == 1 </span><span class="cov3" title="2">{
                fmt.Fprintln(output, advices[0].Savings)
                return
        }</span>

        <span class="cov4" title="3">for _, advice := range advices </span><span class="cov3" title="2">{
                if region </span><span class="cov0" title="0">{
                        fmt.Fprintf(output, "%s/%s: %d\n", advice.Region, advice.Instance, advice.Savings)
                }</span> else<span class="cov3" title="2"> {
                        fmt.Fprintf(output, "%s: %d\n", advice.Instance, advice.Savings)
                }</span>
        }
}

func printAdvicesJSON(advices interface{}, output io.Writer) <span class="cov8" title="11">{
        bytes, err := json.MarshalIndent(advices, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="11">txt := string(bytes)
        txt = strings.ReplaceAll(txt, "\\u003c", "&lt;")
        txt = strings.ReplaceAll(txt, "\\u003e", "&gt;")
        fmt.Fprintln(output, txt)</span>
}

func printAdvicesTable(advices []spot.Advice, csv, region bool, output io.Writer) <span class="cov4" title="3">{
        tbl := table.NewWriter()
        tbl.SetOutputMirror(output)

        header := table.Row{instanceTypeColumn, vCPUColumn, memoryColumn, savingsColumn, interruptionColumn, priceColumn}
        if region </span><span class="cov0" title="0">{
                header = append(table.Row{regionColumn}, header...)
        }</span>

        <span class="cov4" title="3">tbl.AppendHeader(header)

        for _, advice := range advices </span><span class="cov3" title="2">{
                row := table.Row{advice.Instance, advice.Info.Cores, advice.Info.RAM, advice.Savings, advice.Range.Label, advice.Price}
                if region </span><span class="cov0" title="0">{
                        row = append(table.Row{advice.Region}, row...)
                }</span>

                <span class="cov3" title="2">tbl.AppendRow(row)</span>
        }
        // render as CSV
        <span class="cov4" title="3">if csv </span><span class="cov1" title="1">{
                tbl.RenderCSV()
        }</span> else<span class="cov3" title="2"> { // render as pretty table
                tbl.SetColumnConfigs([]table.ColumnConfig{{
                        Name:        savingsColumn,
                        Transformer: text.NewNumberTransformer("%d%%"),
                }})
                tbl.SetStyle(table.StyleLight)
                tbl.Style().Options.SeparateRows = true
                tbl.Render()
        }</span>
}

func init() <span class="cov1" title="1">{
        // Initialize logger with default level
        log = slog.New(slog.NewTextHandler(os.Stderr, &amp;slog.HandlerOptions{Level: slog.LevelInfo}))
        // handle termination signal
        mainCtx = handleSignals()
}</span>

func handleSignals() context.Context <span class="cov1" title="1">{
        // Graceful shut-down on SIGINT/SIGTERM
        sig := make(chan os.Signal, 1)
        signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)

        // create cancelable context
        ctx, cancel := context.WithCancel(context.Background())

        go func() </span><span class="cov1" title="1">{
                defer cancel()

                sid := &lt;-sig

                log.Info("received signal", slog.String("signal", sid.String()))
                log.Info("canceling main command")
        }</span>()

        <span class="cov1" title="1">return ctx</span>
}

func main() <span class="cov0" title="0">{
        app := &amp;cli.App{
                Before: func(ctx *cli.Context) error </span><span class="cov0" title="0">{
                        // Update logger based on flags
                        logLevel := slog.LevelInfo
                        if ctx.Bool("debug") </span><span class="cov0" title="0">{
                                logLevel = slog.LevelDebug
                        }</span> else<span class="cov0" title="0"> if ctx.Bool("quiet") </span><span class="cov0" title="0">{
                                logLevel = slog.LevelError
                        }</span>

                        <span class="cov0" title="0">opts := &amp;slog.HandlerOptions{Level: logLevel}
                        if ctx.Bool("json-log") </span><span class="cov0" title="0">{
                                log = slog.New(slog.NewJSONHandler(os.Stderr, opts))
                        }</span> else<span class="cov0" title="0"> {
                                log = slog.New(slog.NewTextHandler(os.Stderr, opts))
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                },
                Flags: []cli.Flag{
                        &amp;cli.BoolFlag{
                                Name:  "debug",
                                Usage: "enable debug logging",
                        },
                        &amp;cli.BoolFlag{
                                Name:  "quiet",
                                Usage: "quiet mode (errors only)",
                        },
                        &amp;cli.BoolFlag{
                                Name:  "json-log",
                                Usage: "output logs in JSON format",
                        },
                        &amp;cli.StringFlag{
                                Name:  "type",
                                Usage: "EC2 instance type (can be RE2 regexp patten)",
                        },
                        &amp;cli.StringFlag{
                                Name:  "os",
                                Usage: "instance operating system (windows/linux)",
                                Value: "linux",
                        },
                        &amp;cli.StringSliceFlag{
                                Name:  "region",
                                Usage: "set one or more AWS regions, use \"all\" for all AWS regions",
                                Value: cli.NewStringSlice("us-east-1"),
                        },
                        &amp;cli.StringFlag{
                                Name:  "output",
                                Usage: "format output: number|text|json|table|csv",
                                Value: "table",
                        },
                        &amp;cli.IntFlag{
                                Name:  "cpu",
                                Usage: "filter: minimal vCPU cores",
                        },
                        &amp;cli.IntFlag{
                                Name:  "memory",
                                Usage: "filter: minimal memory GiB",
                        },
                        &amp;cli.Float64Flag{
                                Name:  "price",
                                Usage: "filter: maximum price per hour",
                        },
                        &amp;cli.StringFlag{
                                Name:  "sort",
                                Usage: "sort results by interruption|type|savings|price|region",
                                Value: "interruption",
                        },
                        &amp;cli.StringFlag{
                                Name:  "order",
                                Usage: "sort order asc|desc",
                                Value: "asc",
                        },
                },
                Name:    "spotinfo",
                Usage:   "explore AWS EC2 Spot instances",
                Action:  mainCmd,
                Version: Version,
        }
        <span class="cov0" title="0">cli.VersionPrinter = func(_ *cli.Context) </span><span class="cov0" title="0">{
                fmt.Printf("spotinfo %s\n", Version)

                if BuildDate != "" &amp;&amp; BuildDate != "unknown" </span><span class="cov0" title="0">{
                        fmt.Printf("  Build date: %s\n", BuildDate)
                }</span>

                <span class="cov0" title="0">if GitCommit != "" </span><span class="cov0" title="0">{
                        fmt.Printf("  Git commit: %s\n", GitCommit)
                }</span>

                <span class="cov0" title="0">if GitBranch != "" </span><span class="cov0" title="0">{
                        fmt.Printf("  Git branch: %s\n", GitBranch)
                }</span>

                <span class="cov0" title="0">fmt.Printf("  Built with: %s\n", runtime.Version())</span>
        }

        <span class="cov0" title="0">if err := app.Run(os.Args); err != nil </span><span class="cov0" title="0">{
                log.Error("application failed", slog.Any("error", err))
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package spot

import (
        "context"
        "fmt"
        "regexp"
        "strings"
        "sync"
        "time"
)

const (
        // DefaultTimeoutSeconds is the default timeout value in seconds.
        DefaultTimeoutSeconds = 5
)

// Client provides access to AWS EC2 Spot instance pricing and advice.
type Client struct {
        advisorProvider advisorProvider
        pricingProvider pricingProvider
        timeout         time.Duration
        useEmbedded     bool
}

// advisorProvider provides access to spot advisor data (private interface close to consumer).
type advisorProvider interface {
        getRegions() []string
        getRegionAdvice(region, os string) (map[string]spotAdvice, error)
        getInstanceType(instance string) (TypeInfo, error)
        getRange(index int) (Range, error)
}

// pricingProvider provides access to spot pricing data (private interface close to consumer).
type pricingProvider interface {
        getSpotPrice(instance, region, os string) (float64, error)
}

// New creates a new spot client with default options.
func New() *Client <span class="cov1" title="1">{
        return NewWithOptions(DefaultTimeoutSeconds*time.Second, false)
}</span>

// NewWithOptions creates a new spot client with custom options.
func NewWithOptions(timeout time.Duration, useEmbedded bool) *Client <span class="cov2" title="3">{
        return &amp;Client{
                advisorProvider: newDefaultAdvisorProvider(timeout),
                pricingProvider: newDefaultPricingProvider(timeout, useEmbedded),
                timeout:         timeout,
                useEmbedded:     useEmbedded,
        }
}</span>

// NewWithProviders creates a new spot client with custom data providers (for testing).
func NewWithProviders(advisor advisorProvider, pricing pricingProvider) *Client <span class="cov4" title="14">{
        return &amp;Client{
                advisorProvider: advisor,
                pricingProvider: pricing,
                timeout:         DefaultTimeoutSeconds * time.Second,
                useEmbedded:     false,
        }
}</span>

// GetSpotSavings retrieves spot instance advice based on the given criteria.
//
//nolint:gocyclo,cyclop // Complex business logic that benefits from being in a single function
func (c *Client) GetSpotSavings(ctx context.Context, regions []string, pattern, instanceOS string, cpu, memory int, maxPrice float64, sortBy SortBy, sortDesc bool) ([]Advice, error) <span class="cov4" title="17">{
        // Handle "all" regions special case
        if len(regions) == 1 &amp;&amp; regions[0] == "all" </span><span class="cov1" title="1">{
                regions = c.advisorProvider.getRegions()
        }</span>

        <span class="cov4" title="17">result := make([]Advice, 0)

        for _, region := range regions </span><span class="cov4" title="18">{
                // Get advice for this region and OS
                advices, err := c.advisorProvider.getRegionAdvice(region, instanceOS)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                // Process each instance type
                <span class="cov4" title="17">for instance, adv := range advices </span><span class="cov10" title="2713">{
                        // Match instance type pattern
                        if pattern != "" </span><span class="cov9" title="2689">{
                                matched, err := regexp.MatchString(pattern, instance)
                                if err != nil </span><span class="cov1" title="1">{
                                        return nil, fmt.Errorf("failed to match instance type: %w", err)
                                }</span>
                                <span class="cov9" title="2688">if !matched </span><span class="cov9" title="2680">{
                                        continue</span>
                                }
                        }

                        // Filter by CPU and memory requirements
                        <span class="cov4" title="32">info, err := c.advisorProvider.getInstanceType(instance)
                        if err != nil </span><span class="cov1" title="1">{
                                continue</span> // Skip instances we don't have type info for
                        }
                        <span class="cov4" title="31">if (cpu != 0 &amp;&amp; info.Cores &lt; cpu) || (memory != 0 &amp;&amp; info.RAM &lt; float32(memory)) </span><span class="cov2" title="3">{
                                continue</span>
                        }

                        // Get spot price
                        <span class="cov4" title="28">spotPrice, err := c.pricingProvider.getSpotPrice(instance, region, instanceOS)
                        if err == nil </span><span class="cov4" title="28">{
                                // Filter by max price
                                if maxPrice != 0 &amp;&amp; spotPrice &gt; maxPrice </span><span class="cov1" title="1">{
                                        continue</span>
                                }
                        }

                        // Get range information
                        <span class="cov4" title="27">rng, err := c.advisorProvider.getRange(adv.Range)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span> // Skip if we can't get range info
                        }

                        <span class="cov4" title="27">result = append(result, Advice{
                                Region:   region,
                                Instance: instance,
                                Range:    rng,
                                Savings:  adv.Savings,
                                Info:     info,
                                Price:    spotPrice,
                        })</span>
                }
        }

        // Sort results
        <span class="cov4" title="15">sortAdvices(result, sortBy, sortDesc)

        return result, nil</span>
}

// defaultAdvisorProvider is the default implementation of advisorProvider.
type defaultAdvisorProvider struct {
        data    *advisorData
        err     error
        timeout time.Duration
        once    sync.Once
}

func newDefaultAdvisorProvider(timeout time.Duration) *defaultAdvisorProvider <span class="cov2" title="4">{
        return &amp;defaultAdvisorProvider{timeout: timeout}
}</span>

func (p *defaultAdvisorProvider) loadData() error <span class="cov4" title="19">{
        p.once.Do(func() </span><span class="cov2" title="4">{
                p.data, p.err = fetchAdvisorData(context.Background())
        }</span>)
        <span class="cov4" title="19">return p.err</span>
}

func (p *defaultAdvisorProvider) getRegions() []string <span class="cov1" title="1">{
        if err := p.loadData(); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov1" title="1">regions := make([]string, 0, len(p.data.Regions))
        for k := range p.data.Regions </span><span class="cov4" title="33">{
                regions = append(regions, k)
        }</span>
        <span class="cov1" title="1">return regions</span>
}

func (p *defaultAdvisorProvider) getRegionAdvice(region, os string) (map[string]spotAdvice, error) <span class="cov3" title="6">{
        // Validate OS first before loading data
        if !strings.EqualFold("windows", os) &amp;&amp; !strings.EqualFold("linux", os) </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid instance OS, must be windows/linux")
        }</span>

        <span class="cov2" title="5">if err := p.loadData(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="5">regionData, ok := p.data.Regions[region]
        if !ok </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("region not found: %s", region)
        }</span>

        <span class="cov2" title="4">var advices map[string]spotAdvice
        if strings.EqualFold("windows", os) </span><span class="cov0" title="0">{
                advices = regionData.Windows
        }</span> else<span class="cov2" title="4"> {
                advices = regionData.Linux
        }</span>

        <span class="cov2" title="4">return advices, nil</span>
}

func (p *defaultAdvisorProvider) getInstanceType(instance string) (TypeInfo, error) <span class="cov2" title="5">{
        if err := p.loadData(); err != nil </span><span class="cov0" title="0">{
                return TypeInfo{}, err
        }</span>

        <span class="cov2" title="5">info, ok := p.data.InstanceTypes[instance]
        if !ok </span><span class="cov1" title="1">{
                return TypeInfo{}, fmt.Errorf("instance type not found: %s", instance)
        }</span>

        <span class="cov2" title="4">return TypeInfo(info), nil</span>
}

func (p *defaultAdvisorProvider) getRange(index int) (Range, error) <span class="cov3" title="8">{
        if err := p.loadData(); err != nil </span><span class="cov0" title="0">{
                return Range{}, err
        }</span>

        <span class="cov3" title="8">if index &lt; 0 || index &gt;= len(p.data.Ranges) </span><span class="cov1" title="2">{
                return Range{}, fmt.Errorf("range index out of bounds: %d", index)
        }</span>

        <span class="cov3" title="6">r := p.data.Ranges[index]
        return Range{
                Label: r.Label,
                Max:   r.Max,
                Min:   minRange[r.Max],
        }, nil</span>
}

// defaultPricingProvider is the default implementation of pricingProvider.
type defaultPricingProvider struct {
        data        *spotPriceData
        err         error
        timeout     time.Duration
        useEmbedded bool
        once        sync.Once
}

func newDefaultPricingProvider(timeout time.Duration, useEmbedded bool) *defaultPricingProvider <span class="cov2" title="5">{
        return &amp;defaultPricingProvider{
                timeout:     timeout,
                useEmbedded: useEmbedded,
        }
}</span>

func (p *defaultPricingProvider) loadData() error <span class="cov3" title="10">{
        p.once.Do(func() </span><span class="cov2" title="5">{
                rawData, err := fetchPricingData(context.Background(), p.useEmbedded)
                if err != nil </span><span class="cov0" title="0">{
                        p.err = err
                        return
                }</span>
                <span class="cov2" title="5">p.data = convertRawPriceData(rawData)</span>
        })
        <span class="cov3" title="10">return p.err</span>
}

func (p *defaultPricingProvider) getSpotPrice(instance, region, os string) (float64, error) <span class="cov3" title="10">{
        if err := p.loadData(); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov3" title="10">return p.data.getSpotInstancePrice(instance, region, os)</span>
}

// GetSpotSavings provides backward compatibility with the old public function.
// Deprecated: Use Client.GetSpotSavings instead.
func GetSpotSavings(regions []string, pattern, instanceOS string, cpu, memory int, maxPrice float64, sortBy int, sortDesc bool) ([]Advice, error) <span class="cov0" title="0">{
        client := New()
        return client.GetSpotSavings(context.Background(), regions, pattern, instanceOS, cpu, memory, maxPrice, SortBy(sortBy), sortDesc)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package spot

import (
        "context"
        _ "embed"
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "strconv"
        "strings"
        "time"
)

//go:embed data/spot-advisor-data.json
var embeddedSpotData string

//go:embed data/spot-price-data.json
var embeddedPriceData string

const (
        spotAdvisorJSONURL = "https://spot-bid-advisor.s3.amazonaws.com/spot-advisor-data.json"
        spotPriceJSURL     = "https://spot-price.s3.amazonaws.com/spot.js"
        responsePrefix     = "callback("
        responseSuffix     = ");"
        httpTimeout        = 5 * time.Second
)

// awsSpotPricingRegions maps non-standard region codes to AWS region codes.
var awsSpotPricingRegions = map[string]string{
        "us-east":    "us-east-1",
        "us-west":    "us-west-1",
        "eu-ireland": "eu-west-1",
        "apac-sin":   "ap-southeast-1",
        "apac-syd":   "ap-southeast-2",
        "apac-tokyo": "ap-northeast-1",
}

// minRange maps interruption range max values to min values
var minRange = map[int]int{5: 0, 11: 6, 16: 12, 22: 17, 100: 23} //nolint:mnd

// fetchAdvisorData retrieves spot advisor data from AWS or falls back to embedded data.
func fetchAdvisorData(ctx context.Context) (*advisorData, error) <span class="cov2" title="7">{
        client := &amp;http.Client{Timeout: httpTimeout}

        req, err := http.NewRequestWithContext(ctx, http.MethodGet, spotAdvisorJSONURL, http.NoBody)
        if err != nil </span><span class="cov0" title="0">{
                // If request creation fails, try embedded data
                return loadEmbeddedAdvisorData()
        }</span>

        <span class="cov2" title="7">resp, err := client.Do(req)
        if err != nil </span><span class="cov1" title="2">{
                slog.Warn("failed to fetch advisor data from AWS, using embedded data",
                        slog.String("url", spotAdvisorJSONURL),
                        slog.Any("error", err))
                return loadEmbeddedAdvisorData()
        }</span>
        <span class="cov2" title="5">defer func() </span><span class="cov2" title="5">{ _ = resp.Body.Close() }</span>()

        <span class="cov2" title="5">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                slog.Warn("non-200 response from AWS advisor API, using embedded data",
                        slog.Int("status_code", resp.StatusCode))
                return loadEmbeddedAdvisorData()
        }</span>

        <span class="cov2" title="5">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                slog.Warn("failed to read advisor response body, using embedded data",
                        slog.Any("error", err))
                return loadEmbeddedAdvisorData()
        }</span>

        <span class="cov2" title="5">var result advisorData
        err = json.Unmarshal(body, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                slog.Warn("failed to parse advisor data from AWS, using embedded data",
                        slog.Any("error", err))
                return loadEmbeddedAdvisorData()
        }</span>

        <span class="cov2" title="5">slog.Debug("successfully fetched advisor data from AWS")
        return &amp;result, nil</span>
}

// loadEmbeddedAdvisorData loads embedded advisor data as fallback.
func loadEmbeddedAdvisorData() (*advisorData, error) <span class="cov1" title="3">{
        var result advisorData
        err := json.Unmarshal([]byte(embeddedSpotData), &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse embedded spot data: %w", err)
        }</span>

        <span class="cov1" title="3">result.Embedded = true
        slog.Debug("using embedded advisor data")
        return &amp;result, nil</span>
}

// fetchPricingData retrieves spot pricing data from AWS or falls back to embedded data.
func fetchPricingData(ctx context.Context, useEmbedded bool) (*rawPriceData, error) <span class="cov2" title="9">{
        if useEmbedded </span><span class="cov1" title="3">{
                return loadEmbeddedPricingData()
        }</span>

        <span class="cov2" title="6">client := &amp;http.Client{Timeout: httpTimeout}

        req, err := http.NewRequestWithContext(ctx, http.MethodGet, spotPriceJSURL, http.NoBody)
        if err != nil </span><span class="cov0" title="0">{
                // If request creation fails, try embedded data
                return loadEmbeddedPricingData()
        }</span>

        <span class="cov2" title="6">resp, err := client.Do(req)
        if err != nil </span><span class="cov1" title="2">{
                slog.Warn("failed to fetch pricing data from AWS, using embedded data",
                        slog.String("url", spotPriceJSURL),
                        slog.Any("error", err))
                return loadEmbeddedPricingData()
        }</span>
        <span class="cov2" title="4">defer func() </span><span class="cov2" title="4">{ _ = resp.Body.Close() }</span>()

        <span class="cov2" title="4">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                slog.Warn("non-200 response from AWS pricing API, using embedded data",
                        slog.Int("status_code", resp.StatusCode))
                return loadEmbeddedPricingData()
        }</span>

        <span class="cov2" title="4">bodyBytes, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                slog.Warn("failed to read pricing response body, using embedded data",
                        slog.Any("error", err))
                return loadEmbeddedPricingData()
        }</span>

        // Process JSONP response
        <span class="cov2" title="4">bodyString := strings.TrimPrefix(string(bodyBytes), responsePrefix)
        bodyString = strings.TrimSuffix(bodyString, responseSuffix)

        var result rawPriceData
        err = json.Unmarshal([]byte(bodyString), &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                slog.Warn("failed to parse pricing data from AWS, using embedded data",
                        slog.Any("error", err))
                return loadEmbeddedPricingData()
        }</span>

        <span class="cov2" title="4">slog.Debug("successfully fetched pricing data from AWS")
        normalizeRegions(&amp;result)
        return &amp;result, nil</span>
}

// loadEmbeddedPricingData loads embedded pricing data as fallback.
func loadEmbeddedPricingData() (*rawPriceData, error) <span class="cov2" title="6">{
        var result rawPriceData
        err := json.Unmarshal([]byte(embeddedPriceData), &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse embedded spot price data: %w", err)
        }</span>

        <span class="cov2" title="6">result.Embedded = true
        slog.Debug("using embedded pricing data")
        normalizeRegions(&amp;result)
        return &amp;result, nil</span>
}

// normalizeRegions normalizes region codes in the pricing data.
func normalizeRegions(result *rawPriceData) <span class="cov2" title="10">{
        for index, r := range result.Config.Regions </span><span class="cov5" title="360">{
                if awsRegion, ok := awsSpotPricingRegions[r.Region]; ok </span><span class="cov0" title="0">{
                        result.Config.Regions[index].Region = awsRegion
                }</span>
        }
}

// convertRawPriceData converts raw pricing data to a more usable format.
func convertRawPriceData(raw *rawPriceData) *spotPriceData <span class="cov2" title="5">{
        pricing := &amp;spotPriceData{
                Region: make(map[string]regionPrice),
        }

        for _, region := range raw.Config.Regions </span><span class="cov4" title="180">{
                rp := regionPrice{
                        Instance: make(map[string]instancePrice),
                }

                for _, it := range region.InstanceTypes </span><span class="cov6" title="1620">{
                        for _, size := range it.Sizes </span><span class="cov9" title="62095">{
                                var ip instancePrice

                                for _, os := range size.ValueColumns </span><span class="cov10" title="124190">{
                                        price, err := strconv.ParseFloat(os.Prices.USD, 64)
                                        if err != nil </span><span class="cov8" title="15700">{
                                                price = 0
                                        }</span>

                                        <span class="cov10" title="124190">if os.Name == "mswin" </span><span class="cov9" title="62095">{
                                                ip.Windows = price
                                        }</span> else<span class="cov9" title="62095"> {
                                                ip.Linux = price
                                        }</span>
                                }

                                <span class="cov9" title="62095">rp.Instance[size.Size] = ip</span>
                        }
                }

                <span class="cov4" title="180">pricing.Region[region.Region] = rp</span>
        }

        <span class="cov2" title="5">return pricing</span>
}

// getSpotInstancePrice retrieves the spot price for a specific instance.
func (s *spotPriceData) getSpotInstancePrice(instance, region, os string) (float64, error) <span class="cov2" title="10">{
        rp, ok := s.Region[region]
        if !ok </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("no pricing data for region: %v", region)
        }</span>

        <span class="cov2" title="9">price, ok := rp.Instance[instance]
        if !ok </span><span class="cov1" title="1">{
                return 0, fmt.Errorf("no pricing data for instance: %v", instance)
        }</span>

        <span class="cov2" title="8">if os == "windows" </span><span class="cov1" title="1">{
                return price.Windows, nil
        }</span>

        <span class="cov2" title="7">return price.Linux, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package spot provides functionality for retrieving AWS EC2 Spot instance pricing and advice.
package spot

import "sort"

// Range represents an interruption range for spot instances.
type Range struct {
        Label string `json:"label"`
        Min   int    `json:"min"`
        Max   int    `json:"max"`
}

// TypeInfo contains instance type details: vCPU cores, memory, and EMR compatibility.
type TypeInfo struct {
        Cores int     `json:"cores"`
        EMR   bool    `json:"emr"`
        RAM   float32 `json:"ram_gb"` //nolint:tagliatelle
}

// Advice represents spot price advice including interruption range and savings.
type Advice struct { //nolint:govet
        Region    string             `json:"region"`
        Instance  string             `json:"instance"`
        Range     Range              `json:"range"`
        Savings   int                `json:"savings"`
        Info      TypeInfo           `json:"info"`
        Price     float64            `json:"price"`
        ZonePrice map[string]float64 `json:"zone_price,omitempty"`
}

// SortBy defines the sorting criteria for advice results.
type SortBy int

const (
        // SortByRange sorts by frequency of interruption.
        SortByRange SortBy = iota
        // SortByInstance sorts by instance type (lexicographical).
        SortByInstance
        // SortBySavings sorts by savings percentage.
        SortBySavings
        // SortByPrice sorts by spot price.
        SortByPrice
        // SortByRegion sorts by AWS region name.
        SortByRegion
)

// ByRange implements sort.Interface based on the Range.Min field.
type ByRange []Advice

func (a ByRange) Len() int           <span class="cov6" title="6">{ return len(a) }</span>
func (a ByRange) Less(i, j int) bool <span class="cov1" title="1">{ return a[i].Range.Min &lt; a[j].Range.Min }</span>
func (a ByRange) Swap(i, j int)      <span class="cov0" title="0">{ a[i], a[j] = a[j], a[i] }</span>

// ByInstance implements sort.Interface based on the Instance field.
type ByInstance []Advice

func (a ByInstance) Len() int           <span class="cov6" title="5">{ return len(a) }</span>
func (a ByInstance) Less(i, j int) bool <span class="cov5" title="4">{ return a[i].Instance &lt; a[j].Instance }</span>
func (a ByInstance) Swap(i, j int)      <span class="cov1" title="1">{ a[i], a[j] = a[j], a[i] }</span>

// BySavings implements sort.Interface based on the Savings field.
type BySavings []Advice

func (a BySavings) Len() int           <span class="cov3" title="2">{ return len(a) }</span>
func (a BySavings) Less(i, j int) bool <span class="cov6" title="6">{ return a[i].Savings &lt; a[j].Savings }</span>
func (a BySavings) Swap(i, j int)      <span class="cov4" title="3">{ a[i], a[j] = a[j], a[i] }</span>

// ByPrice implements sort.Interface based on the Price field.
type ByPrice []Advice

func (a ByPrice) Len() int           <span class="cov1" title="1">{ return len(a) }</span>
func (a ByPrice) Less(i, j int) bool <span class="cov4" title="3">{ return a[i].Price &lt; a[j].Price }</span>
func (a ByPrice) Swap(i, j int)      <span class="cov3" title="2">{ a[i], a[j] = a[j], a[i] }</span>

// ByRegion implements sort.Interface based on the Region field.
type ByRegion []Advice

func (a ByRegion) Len() int           <span class="cov1" title="1">{ return len(a) }</span>
func (a ByRegion) Less(i, j int) bool <span class="cov3" title="2">{ return a[i].Region &lt; a[j].Region }</span>
func (a ByRegion) Swap(i, j int)      <span class="cov0" title="0">{ a[i], a[j] = a[j], a[i] }</span>

// sortAdvices sorts the advice slice according to the specified criteria.
func sortAdvices(advices []Advice, sortBy SortBy, sortDesc bool) <span class="cov10" title="15">{
        var data sort.Interface

        switch sortBy </span>{
        case SortByRange:<span class="cov6" title="6">
                data = ByRange(advices)</span>
        case SortByInstance:<span class="cov6" title="5">
                data = ByInstance(advices)</span>
        case SortBySavings:<span class="cov3" title="2">
                data = BySavings(advices)</span>
        case SortByPrice:<span class="cov1" title="1">
                data = ByPrice(advices)</span>
        case SortByRegion:<span class="cov1" title="1">
                data = ByRegion(advices)</span>
        default:<span class="cov0" title="0">
                data = ByRange(advices)</span>
        }

        <span class="cov10" title="15">if sortDesc </span><span class="cov1" title="1">{
                data = sort.Reverse(data)
        }</span>

        <span class="cov10" title="15">sort.Sort(data)</span>
}

// interruptionRange represents AWS spot instance interruption frequency ranges.
type interruptionRange struct {
        Label string `json:"label"`
        Index int    `json:"index"`
        Dots  int    `json:"dots"`
        Max   int    `json:"max"`
}

// instanceType represents AWS EC2 instance type specifications.
type instanceType struct {
        Cores int     `json:"cores"`
        EMR   bool    `json:"emr"`
        RAM   float32 `json:"ram_gb"` //nolint:tagliatelle
}

// spotAdvice represents spot pricing advice for a specific instance type.
type spotAdvice struct {
        Range   int `json:"r"`
        Savings int `json:"s"`
}

// osTypes represents spot pricing data by operating system.
type osTypes struct {
        Windows map[string]spotAdvice `json:"Windows"` //nolint:tagliatelle
        Linux   map[string]spotAdvice `json:"Linux"`   //nolint:tagliatelle
}

// advisorData represents the complete AWS spot advisor dataset.
type advisorData struct { //nolint:govet // Field alignment is less important than JSON tag clarity
        Embedded      bool                    // true if loaded from embedded copy
        Ranges        []interruptionRange     `json:"ranges"`
        Regions       map[string]osTypes      `json:"spot_advisor"`   //nolint:tagliatelle
        InstanceTypes map[string]instanceType `json:"instance_types"` //nolint:tagliatelle
}

// rawPriceData represents the raw AWS spot pricing data structure.
type rawPriceData struct { //nolint:govet
        Embedded bool   `json:"-"` // true if loaded from embedded copy
        Config   config `json:"config"`
}

type config struct {
        Rate         string         `json:"rate"`
        ValueColumns []string       `json:"valueColumns"`
        Currencies   []string       `json:"currencies"`
        Regions      []regionConfig `json:"regions"`
}

type regionConfig struct {
        Region        string               `json:"region"`
        InstanceTypes []instanceTypeConfig `json:"instanceTypes"`
}

type instanceTypeConfig struct {
        Type  string       `json:"type"`
        Sizes []sizeConfig `json:"sizes"`
}

type sizeConfig struct {
        Size         string              `json:"size"`
        ValueColumns []valueColumnConfig `json:"valueColumns"`
}

type valueColumnConfig struct {
        Name   string      `json:"name"`
        Prices priceConfig `json:"prices"`
}

type priceConfig struct {
        USD string `json:"USD"` //nolint:tagliatelle
}

// instancePrice represents pricing for an instance type by OS.
type instancePrice struct {
        Linux   float64
        Windows float64
}

// regionPrice represents pricing data for a region.
type regionPrice struct {
        Instance map[string]instancePrice
}

// spotPriceData represents processed spot pricing data.
type spotPriceData struct {
        Region map[string]regionPrice
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
